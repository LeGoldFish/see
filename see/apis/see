function traceback(err, level, b)
    local errors = { }
    local ok, err
    local j = level or 2
    while j < 256 do
        j = j + 1
        ok, err = pcall(_G.error, '', j)
        local name = err:match("^[^:]+")
        if (not b and name == "bios" or name == "see" or name == "xpcall") or not err then break end
        table.insert(errors, err)
    end

    return errors
end

function formatTraceback(err, errors, level)
    level = level < #errors and levels or #errors
    if not err then err = "" end
    local f = "Error: " .. err
    for i = 1, level do
        err = errors[i]
        local ls = err:find(":")
        if ls then ls = ls + 1 end
        local le = err:find(":", ls)
        if le then le = le - 1 end
        local line = ls and le and err:sub(ls, le)
        local location = ls and err:sub(1, ls - 2) or err
        f = f .. "\n@ line " .. (le and line or "?") .. " in " .. location
    end
    return f .. (#errors - level > 0 and "\n... and " .. (#errors - level) .. " more." or "")
end

local function error(err, level, b)
    if term.isColor() then
        term.setTextColor(colors.red)
    end
    print(formatTraceback(err, traceback(err, level, b), 10))
    if term.isColor() then
        term.setTextColor(colors.white)
    end
    _G.error()
end

function errorHandler(err)
    if term.isColor() then
        term.setTextColor(colors.red)
    end
    print(formatTraceback(err, traceback(err, 5, true), 10))
    if term.isColor() then
        term.setTextColor(colors.white)
    end
end

local function copy(t)
    local r = { }
    for k, v in pairs(t) do
        r[k] = v
    end
    return r
end

StandardGlobals = { }

--[[
    Creates a new anonymous class. This class' global table will attempt to index from the parent environment.
    @param SeeRT:rt The VM to run this function for.
    @param function:def The function used to define this class.
    @param table:super The super class for this class. If nil, this class extends see.lang.Object.
]]
function StandardGlobals.class(rt, name, annotations, def)
    local g = getfenv(def)
    local useG = setmetatable({ }, { __index = g })
    local anonName = "__anon[" .. tostring(rt.nAnonClasses) .. "]"
    rt.nAnonClasses = rt.nAnonClasses + 1
    return rt:loadClass(def, annotations, anonName, name, useG)
end

--[[
    Gets the type of a given value.
    @param SeeRT:rt The VM to run this function for.
    @param value:any The value to get the type of.
    @return string|table The type identifier if value if primitive, or the class of value if value is an object.
]]
function StandardGlobals.typeof(rt, value)
    if type(value) == "table" then
        return value.__type or "table"
    end
    return type(value)
end

function StandardGlobals.isprimitive(rt, t)
    return type(t) ~= "table" or not t.__type
end

--[[
    Casts a value to a particular class.
    @param SeeRT:rt The VM to run this function for.
    @param any:value The value to cast.
    @param string|table:castType The type to cast to.
]]
function StandardGlobals.cast(rt, value, castType)
    if StandardGlobals.typeof(rt, value) == castType then
        return value
    end

    if type(castType) == "string" then
        -- Casting to primitive.
        if castType == "string" then
            if type(value) ~= "table" or not value.__type then
                return tostring(value)
            elseif value.__type then
                return value:toString():lstr()
            end
        else
            -- TODO
        end
    elseif type(castType) == "table" then
        if castType.__cast then
            return castType.__cast(value)
        else
            StandardGlobals.throw(rt, rt:loadClassFromAny("see.rt.CastException").new(StandardGlobals.typeof(rt, value), castType))
        end
        -- Casting to Object.
        -- TODO
    else
        --StandardGlobals.throw(rt, rt:loadClassFromAny("see.rt.CastException").new())
    end
end

--[[
    Casts an object to a different class by setting its metatable.
    @param SeeRT:rt The VM to run this function for.
    @param see.base.Object value
]]
function StandardGlobals.reinterpret_cast(rt, value, castType)
    if type(value) ~= "table" or not value.__type then error("Cannot use reinterpret_cast to cast a primitive type.") end
    setmetatable(value, castType.__meta)
end

--[[
    Throws an exception.
    @param SeeRT:rt The VM to run this function for.
    @param see.base.Exception The exception to throw.
]]
function StandardGlobals.throw(rt, exception)
    if exception then
        rt:throw(exception)
    else
        rt:throw(rt:loadClassFromAny("see.rt.RuntimeException").new("Invalid argument to throw."))
    end
end

--[[
    Tries to execute code until an error occurs. Calls catch code if an error occurs.
    @param SeeRT:rt The VM to run this function for.
    @param function:tryFunc Function to run and catch errors from.
    @param function:catchFunc(see.base.Exception) Function to run on error.
]]
function StandardGlobals.try(rt, tryFunc, catchFunc)
    local suc, err = pcall(tryFunc)
    if suc then return end
    --if err then rt.lastException = rt:loadClassFromAny("see.rt.RuntimeException").new(err) end
    catchFunc(rt.lastException)
end

--[[
    Converts a Lua string to a see.base.String.
    @param see.base.String... Strings to concatenate.
]]
function StandardGlobals.STR(rt, ...)
    return rt.base.String.new(...)
end

SeeRT = { }
SeeRT.__index = SeeRT

--[[
    Creates a new SeeRT.
]]
function SeeRT.new(natives, seePath)
    local self = { }
    setmetatable(self, SeeRT)
    self.seePath = seePath

    self.threads = { }
    self.objThreads = { }
    self.threadFilters = { }

    self.nAnonClasses = 0

    self.standardGlobals = { }
    for k, v in pairs(StandardGlobals) do
        self.standardGlobals[k] = function(...) return StandardGlobals[k](self, ...) end
    end

    self.base = { }
    self.rt = { }
    self.event = { }
    self.classes = { }
    self.natives = natives
    self.natives.error = error
    self.archives = { }
    self.classPaths = { }
    self.base.Object = self:loadClassFromAny("see.base.Object")
    self.rt.Class = self:loadClassFromAny("see.rt.Class")
    self.base.Exception = self:loadClassFromAny("see.base.Exception")
    self.base.System = self:loadClassFromAny("see.base.System")
    self.base.Iterators = self:loadClassFromAny("see.base.Iterators")
    self.base.Array  = self:loadClassFromAny("see.base.Array")
    self.base.String = self:loadClassFromAny("see.base.String")
    self.event.Events = self:loadClassFromAny("see.event.Events")
    self.event.UnknownEvent = self:loadClassFromAny("see.event.impl.UnknownEvent")
    self.rt.RuntimeException = self:loadClassFromAny("see.rt.RuntimeException")
    return self
end

function SeeRT:throw(exception, level)
    self.lastException = exception
    _G.error("Uncaught exception " .. exception.__type.__name .. ': "' .. exception.message:lstr() .. '"', level)
end

--[[
    Gets a value out of a table using a valid package string.
    @param table:t The table to search.
    @param string:package The package to look for.
    @param string:del The delimiter to use for the package. default='.'
    @return any The value found.
]]
function getByPackage(t, package, del)
    if not del then del = "%." end
    local f = package:find(del)
    if f then
        return getByPackage(t[package:sub(1, f - 1)], package:sub(f + 1), del)
    else
        return t[package]
    end
end

--[[
    Get package end.
    @param string:package The package to compute the name for.
    @return string:name Name of the package, or nil if invalid or empty package.
]]
function getPackageName(package, del)
    if not del then del = "." end
    for i = #package, 0, -1 do
        if i == 0 or package:sub(i, i) == del then
            return package:sub(i + 1)
        end
    end
end

--[[
    Get the components of a package.
    @param string:package The package to extract components from.
    @return table[string] The components of the given package.
]]
function getPackageComponents(package)
    local components = { }
    for component in package:gmatch("%w[%w%d]*") do
        table.insert(components, component)
    end
    return components
end

--[[
    Finds all annotations in the given code string.
    @param string:code The code to search for annotations in.
    @return table List of annotation strings.
]]
function getAnnotations(code)
    local annotations = { }
    for annotation in code:gmatch("%-%-@[^\n]*") do
        table.insert(annotations, annotation:sub(4))
    end
    return annotations
end

function SeeRT:spawnThread(func, obj)
    local thread = coroutine.create(function() xpcall(func, errorHandler) end)
    self.objThreads[thread] = obj
    table.insert(self.threads, thread)
    self.threadFilters[#self.threads] = -1
    return thread
end

function SeeRT:start(mainClass, ...)
    local Events = self.event.Events
    local UnknownEvent = self.event.UnknownEvent
    local args = self.base.Array.new(...)
    local threads = self.threads
    local f = function() mainClass.main(args) end
    threads[1] = coroutine.create(function() xpcall(f, errorHandler) end)
    local t = self:loadClassFromAny("see.concurrent.Thread").new(f)
    t.co = threads[1]
    self.objThreads[threads[1]] = t
    local threadFilters = self.threadFilters
    local event

    threadFilters[1] = { coroutine.resume(threads[1], args) }
    local cycle = 1
    while true do
        local threadDeaths = { }
        for i = 1, #threads do
            if threadFilters[i] == -1 then
                threadFilters[i] = { coroutine.resume(threads[i], event) }
                if coroutine.status(threads[i]) == "dead" then
                    table.insert(threadDeaths, i)
                    self.objThreads[threads[i]] = nil
                end
            elseif coroutine.status(threads[i]) == "dead" then
                table.insert(threadDeaths, i)
                self.objThreads[threads[i]] = nil
            elseif event then
                if event.ident == "terminate" then
                    error("terminate")
                end

                local passEvent = false

                if #threadFilters[i] == 1 then
                    passEvent = true
                else
                    for j = 2, #threadFilters[i] do
                        if threadFilters[i][j] == event.ident then
                            passEvent = true
                            break
                        end
                    end
                end

                if passEvent then
                    local threadData = { coroutine.resume(threads[i], event) }

                    if not threadData[1] then
                        error(threadData[2], 1)
                        table.insert(threadDeaths, i)
                        self.objThreads[threads[i]] = nil
                    end

                    threadFilters[i] = threadData
                end

                if coroutine.status(threads[i]) == "dead" then
                    table.insert(threadDeaths, i)
                    self.objThreads[threads[i]] = nil
                end
            end
        end

        for i = #threadDeaths, 1, -1 do
            table.remove(threads, threadDeaths[i])
            table.remove(threadFilters, threadDeaths[i])
        end

        if #threads == 0 then break end

        local eventData = { coroutine.yield() }
        local eventParams = { }

        for i = 2, #eventData do
            eventParams[i - 1] = eventData[i]
        end

        if type(eventData[2]) == "table" and eventData[2].__type then
            event = eventData[2]
        else
            local EventClass = Events.getEventClass(eventData[1])
            if EventClass == UnknownEvent then
                xpcall(function() event = EventClass.new(unpack(eventData)) end, errorHandler)
            else
                xpcall(function() event = EventClass.new(unpack(eventParams)) end, errorHandler)
            end
        end
    end
end

--[[
    Loads a class by trying the standard library first, then from class paths.
    @param string:name
    @return table The class loaded.
]]
function SeeRT:loadClassFromAny(name)
    local class = self.classes[name]
    local err

    if class then return class end

    -- Load from the standard library.
    local p = name:gsub("%.", "/")
    class, err = self:loadClassFromFile(fs.combine(fs.combine(self.seePath, "/lib/"), p) .. ".lua", name)
    local lerr = err

    if class then return class end

    -- Load from custom class paths.
    for _, classPath in pairs(self.classPaths) do
        if fs.isDir(classPath) then
            class, err = self:loadClassFromFile(fs.combine(classPath, name:gsub("%.", "/") .. ".lua"), name)
        else
            class, err = self:loadClassFromArchive(self.archives[classPath], name:gsub("%.", "/") .. ".lua", name)
        end
        if class then return class end
    end

    if not lerr:find("Could not read file.") then
        err = lerr
    end

    if not class then
        error("Could not load class " .. name .. ". " .. err)
    end
end

--[[
    Executes annotations onto an environment.
    @param table:env The function environment.
    @param table:annotation Annotation to execute.
]]
function SeeRT:executeAnnotation(env, class, annotation)
    local pindex = annotation:find("%s")

    if not pindex then
        error("Failed to execute annotation for class " .. class.__name .. ".")
    end

    local aname = annotation:sub(1, pindex - 1)

    if aname == "import" then
        local name = annotation:sub(pindex + 1):gsub("%s", "")
        local class = self:loadClassFromAny(name)
        if not class then error("Failed to import class.") end
        env[getPackageName(name)] = class
    elseif aname == "native" then
        local name = annotation:sub(pindex + 1):gsub("%s", "")

        if name == "__rt" then
            env.__rt = self
            return
        end

        local keys = getPackageComponents(name)
        local lk
        local v = self.natives
        local w = env
        local nativeValue = ""
        for _, key in pairs(keys) do
            nativeValue = nativeValue .. key .. "."
            if not v[key] then error("Could not find native value " .. nativeValue) end
            v = v[key]
            if not w[key] or type(w) ~= "table" then
                w[key] = { }
            end
            lw = w
            w = w[key]
            lk = key
        end
        lw[lk] = v
    elseif aname == "extends" then
        local name = annotation:sub(pindex + 1):gsub("%s", "")
        local super = env[getPackageName(name)]
        class.__super = super
        setmetatable(class, super.__meta)
        return true
    end
    return false
end

--[[
    Executes table-style annotations for anonymous classes.
    @param table:env The function environment.
    @param table:annotation Annotation to execute.
    @param string:key The annotation type.
    @param any:value The value of the annotation.
]]
function SeeRT:executeTableStyleAnnotation(env, class, key, value)
    if key == "import" then
        for i = 1, #value do
            self:executeAnnotation(env, class, "import " .. value[i])
        end
    elseif key == "native" then
        for i = 1, #value do
            self:executeAnnotation(env, class, "native " .. value[i])
        end
    elseif key == "extends" then
        if type(value) == "string" then
            self:executeAnnotation(env, class, "extends " .. value)
        elseif type(value) == "table" then
            class.__super = value
            setmetatable(class, value.__meta)
            return true
        else
            -- TODO: throw error
        end
    end

    return false
end

--[[
    Load a class from a file.
    @param string:path The path to the class to load.
    @param string:name The full name of the class to load.
    @return table The loaded class.
    @return string Error message, or nil if successful.
]]
function SeeRT:loadClassFromFile(path, name)
    local fileHandle = fs.open(path, "r")
    if not fileHandle then
        return nil, "Could not read file."
    end
    local code = fileHandle.readAll()
    fileHandle.close()

    -- Setup class execution environment
    local def, err = loadstring(code, name)
    if not def then
        return nil, err
    end
    return self:loadClass(def, getAnnotations(code), name)
end

-- TODO: Make file offset table. Currently, it takes O(N) time to find each file where N is its position in the file.
--[[
    Load a class from a SEE archive.
    @param string:archiveBytes The loaded archive.
    @param string:path The path to the class to load.
    @param string:name The full name of the class to load.
    @return table The loaded class.
    @return string Error message, or nil if successful.
]]
function SeeRT:loadClassFromArchive(archiveBytes, path, name)
    local loc = archiveBytes:find("F" .. path .. "\0", 1, true) + #path + 2
    local fin = archiveBytes:find("\0", loc) - 1
    local code = archiveBytes:sub(loc, fin)

    -- Setup class execution environment
    local def, err = loadstring(code, name)
    if not def then
        return nil, err
    end
    return self:loadClass(def, getAnnotations(code), name)
end

--[[
    Load a class from a definition function.
    @param function:def Class definition for loading.
    @param table[string]:annotations Table of annotation strings.
    @param string:name The name of this class, including the full package.
    @param string:refName The name to use in the class' global table for the class. If given, annotations will be
    processed as an anonymous class annotation.
    @param table:env Environment to use for the class definition.
]]
function SeeRT:loadClass(def, annotations, name, refName, env)
    local className = getPackageName(name)

    if self.classes[name] then
        return self.classes[name]
    end

    if not refName then
        env = copy(self.standardGlobals)
    end

    local anon = refName ~= nil
    refName = refName or className

    -- Setup class inheritance model.
    local class = { }
    class.__meta = { __index = class }
    class.__name = name

    if not self.rt.Class then
        class.__type = class
    else
        class.__type = self.rt.Class
    end

    function class.new(...)
        if not class.init then error("Could not instantiate class " .. refName .. ". No init method.") end
        local self = { }
        setmetatable(self, class.__meta)
        self.__type = class
        self:init(...)
        return self
    end

    -- Import base classes.
    for k, class in pairs(self.base) do
        env[k] = class
    end

    -- Import Events class for convenience.
    env["Events"] = self.event.Events

    -- Setup class environment.
    env[refName] = class
    setfenv(def, env)
    xpcall(def, errorHandler)
    self.classes[name] = class

    local abool = true
    for k, v in pairs(annotations) do
        local ret
        if anon then
            ret = self:executeTableStyleAnnotation(env, class, k, v)
        else
            ret = self:executeAnnotation(env, class, v)
        end
        if ret then
            abool = false
        end
    end

    -- Extend Object by default.
    if abool and self.base.Object then
        class.__super = self.base.Object
        setmetatable(class, self.base.Object.__meta)
    end

    if class.__static then
        class.__static()
    end

    return class
end